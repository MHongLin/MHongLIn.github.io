{"pages":[],"posts":[{"title":"语言是窗，否则是墙","text":"我好像明白了为什么最近大家都说谈恋爱不如做数学题。数学语言穿越历史，超越文化，就算和男女朋友吵到不可开交，也会在 1+1=2 上达成共识是吧。 1 没有以9循环结尾的无限小数记得高一，某次数学老师上课扯犊子说：零点九循环是等于一的。当时全班很震惊，为什么老师说这个是对的，显然不对呀。但是老师又说你看： \\frac{1}{3} = 0.\\dot{3}\\frac{2}{3} = 0.\\dot{6}0.\\dot{9} = 0.\\dot{3} + 0.\\dot{6} = \\frac{1}{3} + \\frac{2}{3} = 1当年不明觉厉的说法，最近偶然又看到了：没有以9循环结尾的无限小数。我回忆起当年的公式: 0.\\dot{9} = 1然后我发现，没有那么震惊，就是这样的，不断循环不就是 1 呀。当年的我不明白循环的深意，因为我学了微积分。考虑无穷数列： 0.9、0.09、0.009、0.0009...$0.\\dot{9}$可以写成这个无穷数列的和，我们称这个无穷数列的和为“几何级数”，它首项是 $0.9$，公比为 $0.1$，它是收敛的，即： 0.\\dot{9} = \\lim_{n \\to + \\infty} \\frac{0.9 \\times (1-0.1^{n})}{1-0.1} = 1显然就没有以9循环结尾的无限小数，因为这样的数都是有限小数和一个收敛的几何级数的和，必然是有限的。 2 语言是窗没有微积分的时候，我似乎不能思考小东西一直加，分母持续接近零，不能描述无限和变化。那些天才提出奇怪问题，敏锐地发现了世界的规律，并且创造文字。然后我学了别人发明的文字，居然也可以打开一扇窗，拥用了思考这些的能力。语言是是窗，当词汇越多，情感越丰富，时间感，空间感，逻辑感越强。 打开这扇窗并不容易。小时候读过的一篇小故事：在地球上没有语言的时候，人类合作十分高效，所有的人类一起造塔，马上就要够到天堂。这是上帝慌了，立刻发明了语言，塔马上就倒了。究其原因是语言作为沟通工具，沟通才没有那么高效。语言本身并没有很多意义。真正的意义是语言背后的情感，事件，物体，处境。先有情感再有语言。语言一方面信息传递，另一方面让其失去了一些东西，因为语言没有办法描述所有的东西，传递也会有误解，所以通往天堂的塔倒了。 需要相信那些经过时间沉淀的优美语言必然是好东西，需要莫名奇妙的努力去学那些枯燥的东西，然后等待缘分。那些我们小时候被老师逼着背的课文，居然在多少年后成为激励自己的精神力量。数学语言那么抽象难学，但是微分方程描述的自然现象堪比画家的笔摄影师的镜头，还就那么短短几行。 不过实在接受不了的东西，也可以放一放，或许没有缘分，或许缘分没到。 3 语言是墙语言也是墙，会区分人。那些一章都看不下去的名著，那些一页都读不下去的数学书。人习惯于接受自己愿意接受的东西，听好听的话，然而很多深刻的东西需要思考。 而现在信息时代，到处都是文字。甚至有写手这种职业，为利益而生，带着某种邪恶目的写别人爱读的文字，让读者渐渐失去批判性思维，钻进语言的茧房。更有甚者，挑拨离间，搬弄是非，或许是思想统治，或许是文化入侵。 4 词汇量相差太多，还能做朋友吗？语言会像墙一样将人区分，如果我们的词汇量相差太多，我们还可以做朋友吗？当然可以，只要有一颗没有偏见的心，语言就是窗。当我们听到自己难以接受的观点，譬如$0.\\dot{9} = 1$，首先应该明白，世界上的每个观点都有局限性与适用范围。与其用自己现有的观点立刻去批判，不如去思考这种说法的来源，然后用心去接纳，去了解，然后语言就是窗，让我们看到更大的世界。 当然谈恋爱和做数学一样，都需要有一颗勇敢的心，努力克服困难。","link":"/2022/04/20/%E7%99%BD%E5%99%AA%E9%9F%B3/%E8%AF%AD%E8%A8%80%E6%98%AF%E7%AA%97/"},{"title":"空中机器人资料&amp;steam编程","text":"省府路小学2022年空中机器人资料：无人机结构+遥控器操作+steam编程 0 基础无人机结构基础 集点160没有上过无人机结构课的小朋友，可以参考下面的资料。 链接：https://pan.baidu.com/s/1f9yXrxtVeGBrteYrxzPb1g提取码：23d4 试飞训练 集点160 遥控器功能 美国手 辨认方向 对频： 将飞机和遥控器同时开机，遥控器LED 1（电源）灯常亮， 长按遥控器右摇杆，遥控器LED 1（电源）、LED2（功能）灯交替闪烁， 直至飞机飞控板LED灯闪烁后， LED1长亮红灯， LED2长亮蓝灯，遥控器 LED2长亮红灯， LED1长亮蓝灯 ，连接成功。 校准： 将遥控器左右两个摇杆同时向正下方拉并保持此动作2S， 当飞控板上的LED闪烁两次变为蓝色光长亮，则校准完成。 排除故障： 操作完成后若故障灯闪烁，请按动左下角红色按钮，直至故障灯熄灭，排除故障 一键起飞与降落：K2键，一键起飞与降落 1 集点 230 使用教程230 使用教程 玩机技巧 链接：https://pan.baidu.com/s/1nBEskGlQ8kDJxHG0tzyu_Q提取码：23d4 编程软件安装包 链接：https://pan.baidu.com/s/1rZNaK_ogos6gCt24PjXdTw提取码：23d4 编程测试 链接：https://pan.baidu.com/s/1-7ZhGY94YjOy933MKMWgog提取码：23d4 使用教程 链接：https://pan.baidu.com/s/1z4nU7XZqogQgO_uxOPe5lA提取码：23d4 地面站使用：集点 230 地面站软件 链接：https://pan.baidu.com/s/1rVyL3LzxRDKRpyBopo8gHg提取码：23d4 教程 链接：https://pan.baidu.com/s/1rwmzGDhOXKnPSZlwJn-S5A提取码：23d4 2 无人机Xg 注意事项无人机兼容乐高积木，但是不建议增加过重的积木 遥控器 对频：左摇杆向上推，向下推 手动起飞：美国手，左摇杆轻轻上推，不要刚拿到飞机就摔坏了（新手慢慢推，感受摇杆的灵敏度） 降落：一定要轻，积木飞机真的很容易坏掉 翻滚：确定无人机电量的充足（桨叶需要足够的动力），并且有足够的空间（上下1米，保证无人机加速与调整的空间，不然会撞到天花板或者撞到地上） 3 无人机编程软件 steam无人机对应的编程软件： 链接：https://pan.baidu.com/s/1FDhOREYuzH9zC_4mp24NXg提取码：23d4 steam安装 解压放在C盘根目录：是整个文件夹放在根目录 双击打开PHPWAMP_Pack.exe，然后在右下角拖盘图标右键启动服务 需要注册一个账号，然后激活（我们一架小飞机的序列号可以激活一次） 双击xgsteam.exe即可开启xgsteam快乐编程 进入编程界面先执行连接命令 4 steam 编程","link":"/2022/03/03/%E5%8F%AF%E7%88%B1%E6%8C%96%E6%8E%98%E6%9C%BA/%E6%97%A0%E4%BA%BA%E6%9C%BA/"},{"title":"风信子占卜大法(bushi)","text":"活的时间长了，就会开始分不清梦境和现实。 1 踩着点来的风信子其实我真的好希望可以收到一束花，总觉得这次生日会收到。农历初五这天，在离校前，我还去办公室看了看我的风信子。是的，它是我自己种的花花，是松鼠推开窗也只是啃了一小口就放过的花花，它在我生日这天全开了。你真好看，我要感谢玉泉的阳光，也感谢你盛开在我的生命里。 农历的生日还是没有收到花花，但是有家里的一桌好吃的家常菜，有好吃的生日蛋糕，然后还能赶上公司的团建。公司的同事都好可爱呀，老板儒雅年轻，想到以后可以一起工作，就觉得很幸福。还有，我滑雪居然不会摔倒哎，可能小时候在院子里滑滑板，将该摔的的都摔完了吧。 2 可爱的人回想起2021年，是很神奇的一年。上半年，是开题结束后拼命做课题的一年。一个人，每天早出晚归，看论文，写程序，日子过得孤单却又飞快。暑假将课题做完了，服务器产数据，我开始找工作了。找工作的这段日子真的遇见了好多人。 世界很小，小到在活动中认识又被我误会的人，我们的误会可以在朋友圈解开。这个故事挺有趣的，我去参加杭州银魂的开放日，就是想去游戏公司转转。有个小龙龙（化名）说我的声音好听，加了个微信。但是后来，我听朋友说他是职协很有名的海王，所以就误会了，不得不承认，女孩子就是有很多偏见。但过了些日子，我们居然给同一个朋友点赞了，我们都很惊讶。这个是我很感激的人，因为他确实帮助过我。小龙龙说这是他很尊敬的学长。误会就这样被这个热心的学长解开。后面我才发现其实小龙龙这个人勇敢又有自己的想法。 世界又很大，大到，有些人说了再见，就再也见不到了。那在商发一起做游戏的朋友，一起看宋城千古情的朋友…还有省府路小学我的孩子们。这群孩子是我的学生，因为你们，我居然也过了一次教师节。2021年下半年，我在省府路小学带一学期的社团课，教空中机器人与智能小车。 孩子们真的很可爱，社团课也可以没有那么大的压力。因为小孩子对科学有好单纯的天然好奇心，我们在嬉戏玩闹中，做出好多有趣的事情。其实我们的上课，就是一群人坐在地上玩，我带着他们拼乐高，帮助他们debug。混熟了，我们也会八卦，他们会好奇我的研究生生活，也会和我吐槽老师家长。我也常常被大家做的东西逗乐，小朋友做的东西沙雕又透着小聪明：那个小朋友做的树上开满飞机，这个小朋友做的“哎呀妈呀”的小丑鱼…当他们说他们喜欢我的课的时候，我真的很开心，其实我只是陪他们玩而已。课程结束，我给每个小朋友准备了零食礼物和贺卡，大家都好感动。我觉得每个小朋友都是小天使，但我也只能陪你们走这一段路。 2021年，我的外公走了。外公走的好意外，走的前两天，视频的时候，他还朝我挥挥手，让我觉得他还挺开心的。结果过了一天就昏迷了… 3 风信子占卜大法：开始胡说八道第一颗风信子谢了，陪伴我的这几天是它一生的绚烂。原来淡紫色风信子的花语是轻柔的气质，浪漫的情怀，悲伤。2022年开始了，看着窗外朦胧的天，确实会让人有种要落泪的冲动，会去想没有开的风信子是什么颜色，有些人还会不会遇见。心中有疑问，就会不自觉寻找答案，有些事可能阅读，出去走走就能找到答案。但有些无能为力的事情呢？那就试试风信子占卜大法。 找一个发芽但是没有开放的风信子 心中写下你要问的问题，等待花开 开花后，看看该颜色风信子的话语，这就是问题的答案 哈哈哈，其实很多时候，答案甚至结局都不重要，因为好的坏的都是风景呀！好的自然开心，坏的就说明快要结束了，新的就要来了，对呀生活是巧克力嘛。 4 有果果还有花花生活真的是巧克力，这不，阳历生日这天，女朋友给了我一个好红的玫瑰，是我见过最大的玫瑰花吧，居然和我风信子的球一样大。吃着炒红果果，拿着花花开心吧，还可以纪念一下在我女朋友生日那天摔坏的牙齿，马上补了就看不见了。下午另一个女朋友还带了巧克力，哇！还是女朋友好呀（爱心，爱心，爱心）。 那么还有两个风信子它是什么颜色呢？着急啥，过两天就知道了呀！","link":"/2022/01/14/%E7%99%BD%E5%99%AA%E9%9F%B3/%E7%8E%89%E6%B3%89%E7%9A%84%E9%A3%8E%E4%BF%A1%E5%AD%90/"},{"title":"数值计算中的精度","text":"。 # 1 数值计算的精度 ## 1-1 数值格式的收敛精度 数值解 $\\tilde{u}_h$ 精确解 $u$ 之间的差值一般和一个参数 $h$ 相关。$C$ 是与 $h$ 无关的常数，$p$ 是收敛精度。 $$\\tilde{u}_h - u = C h^p + O(h^{p+1})$$ ## 1-2 CFD 的收敛精度的计算 CFD 在时间和空间中离散，$min(p,q)$ 决定了收敛精度的大小。 $$R(\\Delta x,\\Delta t)-E(\\Delta x,\\Delta t)=O(\\Delta x^{p+1},\\Delta t^{q+1})$$ 采用不同尺寸的网格$R(\\Delta x)$、$R(\\frac{1}{2}\\Delta x)$、$R(\\frac{1}{4}\\Delta x)$，得到误差函数随网格尺寸 $h$ 的变化关系： R(\\Delta x,\\Delta t)=E(\\Delta x,\\Delta t)+O(\\Delta x^{p+1},\\Delta t^{q+1}) \\approx C \\Delta x^{p}所以： \\frac{R(\\Delta x)}{R(\\frac{1}{2}\\Delta x)}=\\frac{C \\Delta x^{p}}{C(\\frac{1}{2}\\Delta x)^{p}}故： p = \\frac{log\\frac{R(\\Delta x)}{R(\\frac{1}{2}\\Delta x)}}{log2}","link":"/2021/10/08/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%B2%BE%E5%BA%A6/"},{"title":"Matplotlib科研图表","text":"1 折线图1-1 Matplotlib 的子库 Pyplotplot 函数: 线条属性1234plot(x1,y1,[fmt],x2,y2,[fmt],....,** kwargs)# x,y 数据# [fmt]: 基本格式（颜色，标记，线条）# ** kwargs: 标签，线宽等 小例子 1234567891011import matplotlib.pyplot as pltx1 = [0,1,2,3,4,5,6]y1 = [0,23,12,56,73,10,65]x2 = [0,1,2,3,4,5,6]y2 = [56,13,67,12,64,78,13]plt.plot(x1,y1,'r',x2,y2,'c')plt.savefig('fig.png', dpi=100) 基本格式（颜色，标记，线条） 12345678910111213import matplotlib.pyplot as pltx1 = [0,1,2,3,4,5,6]y1 = [0,23,12,56,73,10,65]x2 = [0,1,2,3,4,5,6]y2 = [56,13,67,12,64,78,13]plt.plot(x1,y1,'-ro',x2,y2,'-.cs')# -ro 实线，红色，圆点# -.cs 点划线，青绿色，方点plt.savefig('fig.png', dpi=100) 画了个丑图 1234567891011121314import matplotlib.pyplot as pltimport numpy as npx1 = np.arange(0,6,0.1)y1 = 60*np.sin(x1/2)x2 = [0,1,2,3,4,5,6]y2 = [56,13,67,12,64,78,13]plt.plot(x1,y1,'-r',x2,y2,'-.cs',ms=20)# -r 实线，红色# -.cs 点划线，青绿色，方点, ms 定义大小plt.savefig('fig.png', dpi=100) ** kwargs 123456789101112131415import matplotlib.pyplot as pltimport numpy as npx1 = np.arange(0,6,0.1)y1 = 60*np.sin(x1/2)x2 = [0,1,2,3,4,5,6]y2 = [56,13,67,12,64,78,13]plt.plot(x1,y1,'-r',x2,y2,'-cs',linewidth = '10',ms = '20')# -r 实线，红色# -.cs 点划线，青绿色，方点, ms 定义大小# linewidth 定义线宽plt.savefig('fig.png', dpi=100) xlabel &amp; ylabel 函数：坐标轴标签属性 123456789101112131415161718import matplotlib.pyplot as pltimport numpy as np# 图片中的字体 宋体（STSong）,仿宋（STFangsong）,黑体（SimHei）font={'size':16, # 坐标轴 'color':'black', 'family':'STFangsong' }x1 = np.arange(0,6,0.1)y1 = 60*np.sin(x1/2)plt.plot(x1,y1,'-c')plt.xlabel(&quot;价格 $x$ 元&quot;,fontdict=font)plt.ylabel(&quot;销售量 $n$ 件&quot;,fontdict=font)plt.savefig('fig.png', dpi=100) 图例&amp;标题 1234567891011121314151617181920212223242526272829import matplotlib.pyplot as pltfont_title={'size':24, # 大标题 'y': 1.05, # 调整标题距离 'family':'STFangsong' }font={'size':16, # 坐标轴 'color':'black', 'family':'STFangsong' }x1 = [0,1,2,3,4,6,7]y1 = [51,33,47,72,61,18,33]x2 = [0,1,2,3,4,5,6]y2 = [56,13,67,12,64,78,13]# 设置图例plt.plot(x1,y1,'-ro',label='不锈钢')plt.plot(x2,y2,'-cs',label='铝 ')plt.legend(prop={'family':'STFangsong','size':10})plt.xlabel(&quot;价格 $x$ 元&quot;,fontdict=font)plt.ylabel(&quot;销售量 $n$ 件&quot;,fontdict=font)plt.title(&quot;商品价格与销售量的关系&quot;,fontdict = font_title)plt.savefig('fig.png', dpi=100) 2 温度云图import matplotlib.pyplot as pltimport matplotlib.tri as trifrom matplotlib.pyplot import figure,show,rcimport numpy as npimport pandas as pd","link":"/2021/09/04/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/pyhon%E7%A7%91%E7%A0%94%E5%9B%BE%E8%A1%A8/"},{"title":"排序算法","text":"其实排序挺重要的 排序算法1 桶排序1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main(){ int a[14] = {61,91,23,87,98,61,91,23,87,32,54,85,10,80}; int tong[100] = {}; for(int i = 0; i &lt; 14; i++){ printf(&quot;%d &quot;,a[i]); } printf(&quot;\\n=========\\n&quot;); for(int i = 0; i &lt; 14; i++){ tong[a[i]]++; } for(int i = 0; i &lt; 100; i++){ if(tong[i] != 0){ for(int j = 0; j &lt; tong[i]; j++){ printf(&quot;%d &quot;,i); } } } return 0;} 2 冒泡排序 每趟只能将一个数归位， $n$ 个数，需要 $n-1$ 趟。复杂度 $O(N^2)$ 用冒泡法将学生的成绩排序 冒泡 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;struct student{ char name[10]; int score;};int main(){ struct student a[5]; for(int i = 0; i&lt;5; i++){ scanf(&quot;%s %d&quot;,&amp;a[i].name,&amp;a[i].score); } for(int i = 0; i&lt;5; i++){ printf(&quot;%s's score is %d\\n&quot;,a[i].name,a[i].score); } for(int i = 1; i&lt;5; i++){ for(int j = 1; j&lt;=5-i; j++){ if(a[j-1].score&lt;a[j].score){ struct student temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; } } } printf(&quot;============\\n&quot;); for(int i = 0; i&lt;5; i++){ printf(&quot;%s's score is %d\\n&quot;,a[i].name,a[i].score); } return 0;} 3 快速排序最差的时候是 $O(N^2)$，平均是 $O(NlogN)$。 快排 递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;int a[10] = {61,91,23,87,98,32,54,85,10,80};void quick(int left, int right){ // 0,9 if (left &gt; right){ return; } int temp = a[left]; // 作为基准 int i = left; int j = right; while(i&lt;j){ while (i&lt;j &amp;&amp; a[j]&gt;= temp){ j--; } if(i&lt;j){ a[i] = a[j]; i ++; } while(i&lt;j &amp;&amp; a[i]&lt;= temp){ i++; } if(i&lt;j){ a[j] = a[i]; j--; } } // 基准归位 a[i] = temp; quick(left,i-1); quick(i+1,right);}int main(){ for(int i = 0; i &lt; 10; i++){ printf(&quot;%d &quot;,a[i]); } printf(&quot;\\n=========\\n&quot;); quick(0,9); for(int i = 0; i &lt; 10; i++){ printf(&quot;%d &quot;,a[i]); } return 0;}","link":"/2021/09/03/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"tecplot输出温度云图","text":"tecplot 输出 2 维的温度云图和动画。 云图文件的格式给出温度场中每个点的坐标和温度，画出温度云图 123456789Title=&quot;temperature&quot;Variables=&quot;x&quot;,&quot;y&quot;,&quot;temperature&quot;ZONE I = 3 , J = 2 , F = POINT0 0 11 0 22 0 30 1 11 1 22 1 3 第二行的 x 和 y 对应图片的横纵坐标的标记 I 和 J 分别是横方向和纵方向的坐标，最后输出的结果是这样的： 动画文件的格式一帧帧云图就连成动画了： 123456789101112131415161718192021222324252627282930Title=&quot;temperature&quot;Variables=&quot;x&quot;,&quot;y&quot;,&quot;temperature&quot;ZONE I = 3 , J = 2 , F = POINT0 0 61 0 22 0 30 1 11 1 52 1 3ZONE I = 3 , J = 2 , F = POINT0 0 11 0 82 0 30 1 61 1 22 1 3ZONE I = 3 , J = 2 , F = POINT0 0 31 0 22 0 50 1 11 1 72 1 3ZONE I = 3 , J = 2 , F = POINT0 0 11 0 82 0 30 1 51 1 22 1 3","link":"/2021/07/18/%E6%8A%80%E6%9C%AF/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E8%BD%AF%E4%BB%B6/tecplot%E8%BE%93%E5%87%BA%E6%B8%A9%E5%BA%A6%E4%BA%91%E5%9B%BE/"},{"title":"引用变量","text":"被 palabos 倒逼学 C++。 1 引用变量123456789101112131415161718#include &lt;iostream&gt;int main(){ using namespace std; int rats = 101; int &amp; rodents = rats; // 一个 int 类型的引用 cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; rodents++; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;rats address = &quot; &lt;&lt; &amp;rats; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; // 两个地址的值是一样的 return 0; } rats 和 rodents 指向相同的值和内存单元。引用创建的时候就得赋值。引用应该只和一个变量相关联，不然会有意想不到的问题： 12345678910111213141516171819202122232425// secref.cpp -- defining and using a reference#include &lt;iostream&gt;int main(){ using namespace std; int rats = 101; int &amp; rodents = rats; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;rats address = &quot; &lt;&lt; &amp;rats; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; int bunnies = 50; rodents = bunnies; cout &lt;&lt; &quot;bunnies = &quot; &lt;&lt; bunnies; cout &lt;&lt; &quot;, rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;bunnies address = &quot; &lt;&lt; &amp;bunnies; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; // cin.get(); return 0; } 输出结果： 1234rats = 101, rodents = 101rats address = 0x61fe14, rodents address = 0x61fe14bunnies = 50, rats = 50, rodents = 50bunnies address = 0x61fe10, rodents address = 0x61fe14 1-1 引用用作函数参数引用作为函数的参数，使得函数中的变量名成为程序中变量名的别名。函数可以访问调用函数中的变量。 常引用如果想让函数使用传递给它的信息，有不能修改信息，可以使用 常引用。这个时候编译器发现函数试图修改信息，就会生成错误消息。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;double cube(double a);double refcube(double const &amp;ra); // const 关键字放在 “类型名” 前面后面都可以int main (){ using namespace std; double x = 3.0; cout &lt;&lt; cube(x); cout &lt;&lt; &quot; = cube of &quot; &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; &quot; = cube of &quot; &lt;&lt; refcube(x) &lt;&lt; endl; // cin.get(); return 0;}double cube(double a){ a *= a * a; return a;}double refcube(const double &amp;ra){ int a; a = ra * ra * ra; return a; } 1-2 引用用于结构 和 类对象 是为了处理 “结构” 和 “类” 这些用户定义的类型。 函数返回引用 返回一个作为参数传递给函数的引用。作为参数的引用指向函数使用的数据，所以返回的引用也指向这些数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//strc_ref.cpp -- using structure references#include &lt;iostream&gt;#include &lt;string&gt;struct free_throws{ std::string name; int made; int attempts; float percent;};void display(const free_throws &amp; ft);void set_pc(free_throws &amp; ft);free_throws &amp; accumulate(free_throws &amp;target, const free_throws &amp;source);int main(){ free_throws one = {&quot;Ifelsa Branch&quot;, 13, 14}; free_throws two = {&quot;Andor Knott&quot;, 10, 16}; free_throws three = {&quot;Minnie Max&quot;, 7, 9}; free_throws four = {&quot;Whily Looper&quot;, 5, 9}; free_throws five = {&quot;Long Long&quot;, 6, 14}; free_throws team = {&quot;Throwgoods&quot;, 0, 0}; free_throws dup; set_pc(one); display(one); accumulate(team, one); display(team);// 返回一个作为参数传递给函数的引用 display(accumulate(team, two)); accumulate(accumulate(team, three), four); display(team);// 返回一个作为参数传递给函数的引用 dup = accumulate(team,five); // 结构直接赋值了 std::cout &lt;&lt; &quot;Displaying team:\\n&quot;; display(team); std::cout &lt;&lt; &quot;Displaying dup after assignment:\\n&quot;; display(dup); set_pc(four);// ill-advised assignment accumulate(dup,five) = four; // 左边返回的 dup 被修改了 std::cout &lt;&lt; &quot;Displaying dup after ill-advised assignment:\\n&quot;; display(dup); return 0;}void display(const free_throws &amp; ft){ using std::cout; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; ft.name &lt;&lt; '\\n'; cout &lt;&lt; &quot; Made: &quot; &lt;&lt; ft.made &lt;&lt; '\\t'; cout &lt;&lt; &quot;Attempts: &quot; &lt;&lt; ft.attempts &lt;&lt; '\\t'; cout &lt;&lt; &quot;Percent: &quot; &lt;&lt; ft.percent &lt;&lt; '\\n';}void set_pc(free_throws &amp; ft){ if (ft.attempts != 0) ft.percent = 100.0f *float(ft.made)/float(ft.attempts); else ft.percent = 0;}free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source){ target.attempts += source.attempts; target.made += source.made; set_pc(target); return target;} 引用用于类对象12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string version1(const string &amp; s1, const string &amp; s2);const string &amp; version2(string &amp; s1, const string &amp; s2); int main(){ string input; string copy; string result; cout &lt;&lt; &quot;Enter a string: &quot;; getline(cin, input); copy = input; cout &lt;&lt; &quot;Your string as entered: &quot; &lt;&lt; input &lt;&lt; endl; result = version1(input, &quot;***&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; result = version2(input, &quot;###&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; return 0;}string version1(const string &amp; s1, const string &amp; s2){ string temp; temp = s2 + s1 + s2; return temp;}const string &amp; version2(string &amp; s1, const string &amp; s2) // has side effect{ s1 = s2 + s1 + s2; return s1; } 不能返回一个作用域在函数中，函数结束，它就自动销毁的对象。","link":"/2021/06/08/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/C++%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F/"},{"title":"C++结构 &amp; 运算符重载","text":"被 palabos 倒逼学 C++。 结构一个有构造函数，有成员函数的结构。返回回一个矩形格子的四个点： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;struct Box2D { Box2D() : x0(), x1(), y0(), y1() { } // 冒号后面对成员进行初始化 Box2D(int x0_, int x1_, int y0_, int y1_) : x0(x0_), x1(x1_), y0(y0_), y1(y1_) { } /// Return same box, shifted by (deltaX,deltaY) Box2D shift(int deltaX, int deltaY) const { return Box2D(x0+deltaX, x1+deltaX, y0+deltaY, y1+deltaY); // 返回一个结构 } bool operator==(Box2D const&amp; rhs) const { return x0 == rhs.x0 &amp;&amp; y0 == rhs.y0 &amp;&amp; x1 == rhs.x1 &amp;&amp; y1 == rhs.y1; } // 运算符重载 int x0, x1, y0, y1;};int main(){ Box2D box = {1,10,2,9}; cout &lt;&lt; &quot;box: &quot; &lt;&lt; box.x0 &lt;&lt; &quot; &quot; &lt;&lt; box.x1 &lt;&lt; endl; Box2D box1,box2; cout &lt;&lt; &quot;box1: &quot; &lt;&lt; box1.x0 &lt;&lt; &quot; &quot; &lt;&lt; box1.x1 &lt;&lt; endl; box2 = box.shift(1,2); cout &lt;&lt; &quot;box2: &quot; &lt;&lt; box2.x0 &lt;&lt; &quot; &quot; &lt;&lt; box2.x1 &lt;&lt; endl; box1 = box2; cout &lt;&lt; &quot;box1: &quot; &lt;&lt; box1.x0 &lt;&lt; &quot; &quot; &lt;&lt; box1.x1 &lt;&lt; endl; if (box1 == box2) { cout &lt;&lt; &quot;There are equal!&quot; &lt;&lt; endl; } return 0;} 运算符重载重载运算符 == : operator == () 123bool operator==(Box2D const&amp; rhs) const { return x0 == rhs.x0 &amp;&amp; y0 == rhs.y0 &amp;&amp; x1 == rhs.x1 &amp;&amp; y1 == rhs.y1; box1 == box2 其实是 box1.operator(box2)。第一个对象调用方法，第二个对象作为参数。 1234if (box1 == box2){ cout &lt;&lt; &quot;There are equal!&quot; &lt;&lt; endl;}","link":"/2021/06/08/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/C++%E7%BB%93%E6%9E%84/"},{"title":"C++模板","text":"被 palabos 倒逼学 C++。 1 模板：与类型无关的代码模板让数据，函数的参数，函数的返回值能够是任何类型。模板的声明只能在全局，命名空间或类范围内进行。 1-1 函数模板一个小例子123456789101112131415161718192021222324#include &lt;iostream&gt; using namespace std;template &lt;class T&gt;void sswap(T &amp;a, T &amp;b){ T tmp = a; a = b; b = tmp; }int main(){ int a = 5; int b = 4; sswap(a,b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; return 0;} 1-2 类模板: 一个模板栈的例子定义类模板类模板只是编译指令，实例化都是在编译期完成的。所以不能单独编译，定义和实现都在同一个文件中，最简单的就是放在头文件中。 Palabos 很多功能是用类模板封装的，所以源代码是一堆头文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef STACKTP_H_#define STACKTP_H_template &lt;class Type,int MAX&gt; // 类型参数，非类型参数class Stack{private: Type items[MAX]; int top; public: Stack(); bool isempty(); bool isfull(); bool push(const Type item); bool pop(Type &amp;item); };template &lt;class Type,int MAX&gt;Stack&lt;Type,MAX&gt;::Stack(){ top = 0;}template &lt;class Type,int MAX&gt;bool Stack&lt;Type,MAX&gt;::isempty(){ return top == 0;}template &lt;class Type,int MAX&gt;bool Stack&lt;Type,MAX&gt;::isfull(){ return top == MAX;}template &lt;class Type,int MAX&gt;bool Stack&lt;Type,MAX&gt;::push(const Type item){ if (top &lt; MAX) { items[top++] = item; return true; } else return false;}template &lt;class Type,int MAX&gt;bool Stack&lt;Type,MAX&gt;::pop(Type &amp;item){ if (top &gt; 0) { item = items[--top]; return true; } else return false; }#endif 模板的具体化12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &quot;stacktp.h&quot;using namespace std;int main(){ Stack&lt;string,3&gt; st; // 传入类型参数和非类型参数 char ch; string po; cout &lt;&lt; &quot;A: push\\nP: pop\\nQ: quit\\n&quot;; while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != 'Q') { while (cin.get() != '\\n') continue; if (!isalpha(ch)) { cout &lt;&lt; &quot;input again:&quot;; continue; } switch(ch) { case 'A': case 'a': cout &lt;&lt; &quot;Enter: &quot;; cin &gt;&gt; po; if (st.isfull()) cout &lt;&lt; &quot;stack already full\\n&quot;; else st.push(po); break; case 'P': case 'p': if (st.isempty()) cout &lt;&lt; &quot;stack already empty\\n&quot;; else { st.pop(po); cout &lt;&lt; &quot;PO #&quot; &lt;&lt; po &lt;&lt; &quot; popped\\n&quot;; break; } } cout &lt;&lt; &quot;A: push\\nP: pop\\nQ: quit\\n&quot;; } cout &lt;&lt; &quot;Bye\\n&quot;; return 0; } 成员模板：作为结构，类或模板类的成员 下面的模板类将一个 模板类 和 模板函数作为其成员: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using std::cout;using std::endl;template &lt;typename T&gt;class beta{private: template &lt;typename V&gt; // 模板类作为成员 class hold { private: V val; public: hold(V v = 0) : val(v) {} void show() const { cout &lt;&lt; val &lt;&lt; endl; } V Value() const { return val; } }; hold&lt;T&gt; q; // 成员模板的对象 hold&lt;int&gt; n; // 成员模板的对象public: beta( T t, int i) : q(t), n(i) {} // 构造函数这样传递信息 template&lt;typename U&gt; // 函数模板作为成员 U blab(U u, T t) { return (n.Value() + q.Value()) * u / t; } void Show() const { q.show(); n.show();}};int main(){ beta&lt;double&gt; guy(3.5, 3); cout &lt;&lt; &quot;T was set to double\\n&quot;; guy.Show(); cout &lt;&lt; &quot;V was set to T, which is double, then V was set to int\\n&quot;; cout &lt;&lt; guy.blab(10, 2.3) &lt;&lt; endl; cout &lt;&lt; &quot;U was set to int\\n&quot;; cout &lt;&lt; guy.blab(10.0, 2.3) &lt;&lt; endl; cout &lt;&lt; &quot;U was set to double\\n&quot;; cout &lt;&lt; &quot;Done\\n&quot;; // std::cin.get(); return 0; } 将模板作为参数类似于类，模板类可以用作于基类，也可以用做于组件类，还可以用作于其他模板类型的参数。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &quot;stacktp.h&quot; // 需要用到前面这个头文件using namespace std;template &lt;template &lt;class Type,int MAX&gt; class Thing&gt; // template &lt;class Type,int MAX&gt; class 类型的参数 Thingclass Crab{private: Thing&lt;int,5&gt; s1; Thing&lt;double,5&gt; s2;public: Crab() {}; // assumes the thing class has push() and pop() members bool push(int a, double x) { return s1.push(a) &amp;&amp; s2.push(x); } bool pop(int &amp; a, double &amp; x){ return s1.pop(a) &amp;&amp; s2.pop(x); }}; int main(){ Crab&lt;Stack&gt; nebula; // Stack must match template &lt;typename T&gt; class thing int ni; double nb; cout &lt;&lt; &quot;Enter int double pairs, such as 4 3.5 (0 0 to end):\\n&quot;; while (cin&gt;&gt; ni &gt;&gt; nb &amp;&amp; ni &gt; 0 &amp;&amp; nb &gt; 0) { if (!nebula.push(ni, nb)) break; } while (nebula.pop(ni, nb)) cout &lt;&lt; ni &lt;&lt; &quot;, &quot; &lt;&lt; nb &lt;&lt; endl; cout &lt;&lt; &quot;Done.\\n&quot;; return 0; }","link":"/2021/06/03/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/C++%E6%A8%A1%E6%9D%BF/"},{"title":"palabos使用-Cmake编译","text":"各种工具，可真多。 1 make &amp; makefilesg++ 编译的 4 个过程 预处理，-E 表示编译器仅对输入文件进行预处理，之后还是源文件 1g++ -E test.cpp -o test.i 编译，产生汇编语言文件 1g++ -S test.i -o test.s 汇编语言，生成机器语言的目标代码(注意这边的 c 是个小写的)：正确的源文件都可以被编译成目标文件，每个源文件都有一个对应的目标文件。编译器只检查语法，函数和变量是否被声明。 1g++ -c test.s -o test.o 链接，生成可执行文件：使用目标文件链接成库文件。目标文件太多了，链接时需要指出目标文件的文件名，对于编译很不方便，给目标文件打个包，这个包就是库文件。链接器会在所有的目标文件中寻找函数的实现。 1g++ test.o -o test 一个小例子说明 makefile makefile: 文件依赖关系+编译命令 当需要编译很多源文件的大工程时，可以使用 makefiles 让编译更高效。makefiles 是一系列的 gcc/g++ 命令，并且记录文件之间的依赖关系。Make 是一个工具，执行 makefiles 中的内容。 Hello.cpp 具体函数的实现 12345678910111213//这是Hello.cpp#include&lt;iostream&gt;#include &quot;Hello.h&quot;using namespace std; Hello::Hello(){} int Hello::Display(){ cout &lt;&lt; &quot;Hello,ivy!\\n&quot; &lt;&lt; endl; return 0;} Hello.h 头文件中是声明 123456//这是Hello.hclass Hello { public: Hello(); int Display();}; main.cpp 总的文件 1234567#include &lt;iostream&gt;#include &quot;Hello.h&quot;int main(){ Hello theHello; theHello.Display(); return 0;} 用命令行的方法分四步编译 12345678$ g++ -E Hello.cpp -o Hello.i$ g++ -E main.cpp -o main.i$ g++ -S Hello.cpp -o Hello.s$ g++ -S main.cpp -o main.s$ g++ -c Hello.cpp -o Hello.o$ g++ -c main.cpp -o main.o$ g++ Hello.o main.o -o main$./main 用 makefile 文件编译，学习写这个文件看这边 $\\to$ makefile clean 命令后面没有依赖关系，所以得用 make clean 命令来执行。 12345678Hello:mian.o Hello.o g++ main.o Hello.o -o Hellomian.o:main.cpp g++ -c main.cpp -o main.o Hello.o:Hello.cpp g++ -c Hello.cpp -o Hello.oclean: rm Hello.o main.o Hello makefile 中定义变量，并且用 $(变量名) 使用变量。类似于宏，只要修改一处即可。 12345678910object = main.o Hello.oHello: $(object) g++ $(object) -o Hellomian.o:main.cpp g++ -c main.cpp -o main.o Hello.o:Hello.cpp g++ -c Hello.cpp -o Hello.oclean: rm $(object) Hello makefile 可以自动推导依赖文件的关系，以及命令 12345678object = main.o Hello.oHello: $(object) g++ $(object) -o Hellomian.o:Hello.o:clean: rm $(object) Hello 2 Cmake对于大型工程，写 makefile 是很困难的，于是有了 Cmake 这个工具。Cmake 是一个自动生成 makefiles 的工具。CMake是一个跨平台的安装编译工具，可以用简单的语句来描述所有平台的安装(编译过程)。 语法特性介绍 基本语法格式：指令（参数1 参数2…） 参数用括弧括起来，参数之间用空格或是分号分开 指令是大小写无关的，参数和变量是大小写相关的 变量使用${}方式取值，但是在 IF 语句中直接使用变量名 重要指令和常用变量 重要指令 12345678910111213141516171819202122232425# 指定最低版本要求cmake_minimum_required(VERSION 2.8.3)# 指定工程名称为 HELLOWORLDproject(HELLOWORLD)# 显式定义变量，定义变量 SRC，其值为 sayhello.cpp hello.cppset(SRC sayhello.cpp hello.cpp)# include_directories 指定头文件的搜索路径，相当于 g++ 编译器的 -l 参数include_directories(/usr/include/myincludefolder ./include)# link_directories 向工程中添加多个库文件的搜索路径link_directories(/usr/lib/mylibfolder ./lib)# add_library 通过前面定义的变量生成 libhello.so 共享库add_library(hello SHARED ${SRC})# add_executable编译 main.cpp 生成可执行文件 mainadd_executable(main main.cpp)# target_link_libraries 为可执行文件 main 链接 hello 动态库target_link_libraries(main hello)# ... 源文件中主目录的 CMakeLists.txt 通过 add_subdirectory 添加子目录的 CMakeLists.txt 常用变量 1234# 变量 CMAKE_BUILD_TYPE，设置编译类型为 Debugset(CMAKE_BUILD_TYPE Debug) # ... Cmake 编译工程 外部构建： 创建 build 文件夹，加输出的中间文件都放在这个里面 Cmake 代码实践1：超级小的工程还是 一个小例子说明 makefile 中的三个文件，文件结构： 12345678# 指定最低版本要求cmake_minimum_required(VERSION 3.0)# 指定工程名称project(HELLO)# 生成可执行文件add_executable(main main.cpp) 参考资料简单构建linux c++ cmake工程结构 干货：构建C/C++良好的工程结构 《CMake实践》 基于VSCode和CMake实现C/C++开发 | Linux篇 CMake 手册详解","link":"/2021/05/18/%E6%8A%80%E6%9C%AF/palabos/palabos2%E7%BC%96%E8%AF%91/"},{"title":"palabos 安装使用","text":"初步体验一下 palabos 的使用。 palabos 是基于 LBM 方法的开源库。从官网下载，解压之后就是一堆 palabos 的源代码。源代码是用 C++ 写的，里面有各种类和对象，可供使用。 1 安装虚拟机为了编译方便，最好是在 Linux 的环境下使用。所以先安装虚拟机。 安装VMware Tool，让屏幕变大一点。 2 运行一个标准案例下载palabos。 一个方腔流的案例按照官网的流程试一下： 安装编译所需要的软件 1$ sudo apt install gcc clang cmake make 配置 MPI 等功能 1$ sudo apt install libopenmpi-dev imagemagick libhdf5-dev libhdf5-mpi-dev ccache 试着跑一个案例 12345$ cd palabos/examples/showCases/cavity2d/build$ cmake ..$ make$ cd ..$ ./cavity2d 这样就完成了一个方腔流的案例。 build 文件夹 CMakeCache.txt Makefile 在 build 文件夹中，使用 Cmake .. 生成的编译用的文件。 cmake_install.cmake libpalabos.a 一个二进制的文件 CmakeFiles 文件夹 将 src 文件夹中所有的源文件都编译了，怪不得那么久。 3 以后要使用这个开源包，还得明白 LBM 的基本算法，有一定的编程知识，熟悉包里面定义的数据，类等。","link":"/2021/05/04/%E6%8A%80%E6%9C%AF/palabos/palabos1%E5%AE%89%E8%A3%85/"},{"title":"为您读书","text":"将喜马拉雅朗读亭生成的作品粘贴到个人主页的一种方法：这是一篇可以听的文章，为您读书。 今天真的很巧，是世界读书日，我很便宜地买到了好多几米的绘本。刚好昨天在黄龙录了好多声音，本想着今天整理了发一下，没想到这么曲折，试过各种方法，网易家的外链是最好看的。为了发这个文章，我居然成为了网易音乐人，而且，审核都超级快，各种审核一天就完成了。 1 诗歌文学 《简爱》: 最早的霸道总裁爱上我，独立倔强的勃朗特姐妹 《鲁兵逊漂流记》：比困难更可怕的是害怕困难的心理，I am lucky to be alive. 有一位小姐，她甜美善良 (爱的小心翼翼) 爱不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地 同一人事上，第二次凑巧是不会有的。我只爱过一个正当最好年纪的人。 2 幽默搞笑 就算让我知道我永远在暗恋，我也会笑着说再见。你好，我是 F 班 的袁湘琴。 佐罗偷情（这个太有趣了，被网易云和谐了，改了名称，我还以为自己传错了） 我要你做我的圣诞礼物 不要怀疑我们之间的友谊，我只是穷了而已 圣诞节到了，单身狗即将升级为雪橇犬 3 童话故事 我爱你，这么大 一个人读多个角色，太有趣了。以后有了孩子，给她讲故事，可以考虑给自己开个小电台，专门给小朋友讲故事。 4 几米童话 《向左走，向右走》：他们彼此深信，是瞬间的热情让他们相遇，这种相遇是美丽的 我不擅长交际 只为比你们高一点，我在跷跷板上坐了很久，其实我并不喜欢坐在这里 平凡的我遇见了所有的不平凡，什么时候可以遇见平凡的你 如果我变得和你想的不一样，请爱我原来的样子 怎样发布朗读呢 在喜马拉雅朗读亭读自己喜欢的文字 下载到手机里，并找到文件的位置，将它传到电脑上 我们下载的文件后缀是 m4a，没关系，直接将后缀改成 mp3 注册成为网易云音乐的——网易音乐人 上传自己的声音文件 生成外链播放器: 注意取消勾选自动打开，要不像这篇文章这样的情况，打开后就像到了菜市场 撒花","link":"/2021/04/23/%E5%8F%AF%E7%88%B1%E6%8C%96%E6%8E%98%E6%9C%BA/%E6%9C%89%E5%A3%B0%E7%AC%94%E8%AE%B0%E6%9C%AC-%E4%B8%BA%E4%BD%A0%E8%AF%BB%E4%B9%A6/"},{"title":"《像外行一样思考，像专家一样实践》笔记","text":"读完这本书，我才发现，那位讲数值计算的鲁老师是非常聪明的，他掌握了这本书第三章的精髓。BEST FIRST 1 像外行一样思考，像专家一样实践 海阔天空的构思 外行人的思考方法是直接从结论开始去做，从希望得到的结果开始去做。 海岸线的长度不一致：分形学说 在研究的过程中如果没有数学这个专业工具是绝对不可能成功的。 内容宽泛的理论 框架理论中包含了神经生理学、计算理论学、数学、心理学等等目前所知道的理论，并且这个理论足够含糊，无论什么现象都可以包括进来。——明斯基 身为专家要有舍弃固有思想、大胆创新的魄力与勇气 除了用机器语言编程外，为什么还需要别的语言呢？——冯诺依曼 要勇于反对别人的意见 想出引人入胜的点子，只要反对大家所说的就可以了，大家都认同的好方法基本上都不太令人满意。——明斯基 如果数量达到阿伏伽德罗常数，则计算机也不能全部检查。 理论越是适用于简单、抽象的问题，越有价值。 越简单、抽象化就会产生越绝妙，越鲜明的理论：物理书上的小球。 用情景推动研究进展：情景的关键，是对人和社会有何作用。对情节描述的基本能力是对未来的预见能力。 所谓构想力是限定问题的能力。如果在解决问题时，能准确地限定问题关键点，将会非常有效。如果能给问题下个定义，就已经解决了 60%。 智慧体力——所谓集中精力，就是让自己成为问题本身 做研究和搞开发没有具体的目标是绝对不行的 与别人交流，完善自己的构思 能做出好结果的方法，其中必有诀窍。结果不会像魔术一样自己跑出来。识别结果的能力很重要。 创造的基础是模仿 2 计算机的挑战：问题的解决能力与教育认识通过由细胞构成的叫做神经网的硬件来进行计算的。计算时这些神经细胞不是一个个单独进行，而是组成网状结构进行思考。 模拟计算：将要研究的对象换成与之相似的现象。比如用绳子计算悬链线方程。 现如今，人和计算机都是计算出最优答案，不是最佳答案。 真正的能力是解决生活中具体问题的能力。、 从例题入手再分析问题是个不错的方法。从例题开始，得出事物之间的关联，再建立普遍意义的法则。从形式到实质。 创造力，规划能力的基础是记忆力。 3 表达：演讲，会话，写作所有的技巧都是建立在实力的基础之上的，要对自己的课题深刻理解。 3-1 演讲好酒也怕巷子深 将想法、研究成果传达给他人，说服他人也是研究的重要环节。 英语很重要，这无关爱不爱国。英语成为通用语言，由经济、政治，地缘政治等决定。 好的想法和结果是一切的基础。 设身处地地为听众讲，讲出来的东西就会自然精彩。 不做铺垫直切主题——令人深思快速直切主题最好的方法：先出手中最好的牌。BEST FIRST :将手中的幻灯片按重要性排序，才是最好的做法。 研究背景，研究现状等，知道的人是知道，不知道的人还是不知道。所以大多数人会觉得没意思，应该从观众最关心的地方开始。 听众最感兴趣的是开始的部分。一开始听众注意力比较集中，要抓过来。 观众听到一个有趣的观点，自然会想知道是怎么得出的。最重要的讲完了，目的达到了，后面随便怎么结束。 用说明的方式陈述结果 不要以道歉开始。先说自己解决了什么问题，发言时充满自信，让大家觉得，听我的演讲是有好处的。 只要内容正确，说的不精细也行。论文需要正确，缜密。演讲可不是这样，只有一条听众不能控制的时间粥，要先吸引观众注意，再进行情节的展开。 不是通过说明得到认可，而是从认可的基础上进行说明说明是想人理解，然而事实并不是这样。说明一个对方完全不知道的东西是很难的。将新知识，与听众已有的知识联系起来。 复杂的理论也要让人理解。很多复杂理论的出发点是简单自然而然的事情。将复杂的理论讲得通俗有趣，选择有趣浅显大家关心的例子。 看着对方的眼睛-自信自信来自与正面积极的想法 ：这个让我想起一件事情。当我们要做开题报告的时候，我听见了两种声音。声音 1 ：我报告的时候会被怼的，可怕。声音 2 ：我要大胆表达自己的想法，老师提出意见是一件好事情。 作为一个领导，一定要把自己的自信传染给部下：看到这里，耳畔突然传来涛涛老师的声音，你们一定能找到工作的。 论点鲜明的讨论，讨论最重要的是不要忘记讨论内容是什么。 尽量不要用 but 之类的词，否定词开头会给对方反感。 留给别人的印象最好和实力相符合。 提高英语会话的秘诀：抢着说，大声讲，静下心来听。 3-3 论文是一部推理小说 写论文最重要的事情是，只有一个中心思想。 好的论文：划时代的构思，杰出的成果，好的故事情节（读者参与进去：到底怎么了？难道是？问题终于解决了），写作技巧（构思和组织能力）。 论文的题目，论题明确，需要将论文的重要论述内容全部写出来。 章节构成，只看目录就能想象论文的内容。 段落，一个段落仅限于论述一个观点。 起承转合的构思： 起：让读者觉得读你的论文会得到好处。 承：针对期待展开情节，巧妙地设定假设。如何设定一个研究课题，在哪部分限定问题。 转：循序渐进地引导解答的关键。提出关键想法，让读者逐渐了解这些想法的效果。 合：将最重要的研究成果一并提出。带着一点自傲，这么好的结果，你做的出来吗？ 避免使用有歧义的词语 3-4 提案——当对象是上司时要通俗易懂具有影响力的研究： 新领域的研究 临界领域的研究 研究领域很窄，并且只有自己才能做到的研究 想要得到钱，除了课题本身，还要鲜明地表达出更深远层次上的有益内容。让别人觉得你的成功率高 3-5 关于演讲和英语的三个奇怪建议 演讲还是别准备得太好 展示的资料不要做成让别人一眼就可以看明白:做成仅仅有一些内容看不明白。然后才有的说呀！ 英语教育还是不要过早：“有效语言”的思考打牢靠。 4 寻求决断与明示的速度：关于日本与世界、自己与他人的思考 能用则用的现实实用主义 互联网的价值：更多更广泛的人和工作 强迫观念与存在感：每个人都在潜意识中认为别人在注意自己。事实上其实没有多少人在意，被看见也没关系。 吸引人的领导技术：领导人要能准确判断当前形势，能够制定出计划方针。 西部剧的警长，时代剧的地方官：在美国领导各方面都是最厉害的 无法顺利进行的时候，干脆转掉方向 评价是很主观的东西：为了做到“客观评价”而费事制定的规则没有什么意义。","link":"/2021/03/31/%E9%9D%92%E9%9D%92%E8%8A%B3%E8%8D%89/%E3%80%8A%E5%83%8F%E5%A4%96%E8%A1%8C%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83%EF%BC%8C%E5%83%8F%E4%B8%93%E5%AE%B6%E4%B8%80%E6%A0%B7%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0/"},{"title":"《暗时间》笔记","text":"在玉泉图书馆，这本《暗时间》，居然和霍金的《时间简史》一样，被安排在理论物理学的书架上，害我找了很久。但是这本书，不管是名字还是封面，都不太像一本随笔。 1 暗时间 将问题放在潜意思的最高级：可以借助潜意识的力量，快速搜集线索。我想到那位发现苯环的科学家。 切换任务，在无形中会消耗大量时间：潜意识总是会跳出来打扰我。 如果你有一段时间，不知道花在A上还是B上，就不行，时间没了就是没了：好有道理，关于学 C++ 还是 Python，答案是两个都学，并且学的更多。 学一个东西之前，要积累充分多的疑惑。问好引发思考。 记忆与学习: 能在用的时候提取出来的知识才是你的知识。记忆编码，应该多一点提取线索，富含线索的记忆是罗马，条条大路通罗马。 情绪，环境，味道，声音都可以被当成提取线索被编码。写文章努力弄出一些关键词，作为回忆的 key。那些会总结，命名的人真的很厉害，总结出了 key。 从既有经验中总结知识的时候，应该适当抽象来得出更广的知识，方便后面举一反三。其实情绪是强化记忆的最佳线索和最佳提取工具。 2 思维改变生活2-1 逃出你的肖申克 世界是复杂的，各种因素互相影响。未来是不确定的，正确的行为不一定有正确的结果。别人的经验，不一定适用于自己的事情。 情绪系统：我们平时的行动和判断强烈依赖于情绪系统的输出，在情绪面前，理性的力量太弱小了。 先验假设：先验假设是在长期生活中无意识积累出来的有价值的假设,从多义性的信息源中抽取一种最靠谱的解释。当大脑中两个假设互相冲突的时候，更强硬的那个获胜。先验假设虽然可以帮助消除二义性，但是它是认知偏差的来源。消除二义性，需要引入新的线索。 大脑接收到的信息是很多歧义的，先验性假设产生偏见。 打破偏见：知识的局限性让自己很难证伪自己的猜想。唯一的办法就是开放心态，多积累不同的知识，和不同经历的人聊天。 金融市场上，小聪明的人从短趋势得到的经验是在时间上没有随机取样的可能有篇的数据集。智慧玩家应该无偏见的平均分配资金，投资指数。 记忆的构建性：很多记忆并不真实呢，掺杂情绪，先验假设。 偏见会成为自我实现的语言和自我妨碍的陷阱：女孩子就是学不好数学。我默写不好就是没有努力。 高级认知与本能：我们是生活在信息时代的远古人。很多时候，高级认知斗不过本能。 情绪 emotion 和动力 motion ：对事情的坚持来源于情感系统，没有这个系统的支持，很难走的远。 大脑非常善于为自己的行为作出合理的解释。真正的理由往往在我们意识触及不到的地方，由情绪大脑所掌控。 我们知道答案，但是往往不知道真正的求解过程。 去敏感化：通过理性训练，让自己在情感上不再畏惧。其实这边我想到了《鲁冰逊漂流记》：可怕的不是困难本身，而是害怕困难的心理。化用一下，一个问题有多难，不是因为问题本身，而是你自己认为解决它需要很多思维体力。其实解决之前哪知道要多少时间呢？ 自我辩护：大脑更容易相信对自己有利的判断，只要有可能，就相信是真的。不愿意接受不利的解释，甚至是事实。而且我们会勤于收集对自己有利的证据，拒绝对自己无力的证据。 两种解释：事情会有两种解释，平凡的解释，疯狂的解释。从自我辩护的角度看，事情有两种解释，对自己有利的解释，对自己不利的解释。 思想钢印：每个人都有思想钢印，由经验打造，由自尊维护，牢不可破。人的认知很多功能是硬编码的。 习惯是自我巩固的：单纯的自制是很痛苦的，改变习惯需要知识。 反思：将潜意识里面的东西从幕后拉出来，就有了反思的可能，而不是任由它左右你的行动。 Much of will is skill：意志力很大程度上来源于正确的方法，而非天生。 Much of intelligence is knowledge：智力不是天生的。 自利归因：一件事情发生的原因归结为对自己有利的情况。 事后归因：一旦知道结果后，所有指向这个结果的理由都变得显然和充分。不指向这个结果的理由都变得不显然和不充分。 注意力等于事实：世界是这个样子，是因为我看到它是这个样子。 2-2 小马过河不应该听小松鼠的 新知识的困难难以评估：知识需要掌握后才能豁然开朗。智商没有很大的差别，真实情况是，有人能做到，你也可以，如果有差别，可能只是时间的问题。 局部最优不一定是全局最优：眼前的利益最大化，只是小聪明。一昧绕开困难，永远得不到克服困难带来的收益。 自信和谦卑不矛盾: 前者相信自己能做到，后者不总是认为自己是对的。 3 跟波利亚学解题3-1 跟波利亚学解题这本书是我中学的时候看过的一本书。波利亚认为：思维教学，如果不能将解决问题后面的思维过程教给学生，那么就是没有意义的。解题的总目的是充分挖掘已知条件。抽象很重要。 作者总结的几个关键，但然这些方法都需要训练： 时刻不忘未知量因：这边和潜意识那边很像。专心的力量吧。 用特例引发思考：特例计较简单，但也有问题的本质结构，几个特例寻找一般解。 倒推法考：之所以这么厉害，因为结论中也蕴含丰富的条件，借助结论中的知识我们可以更好搜索解空间 试错 调整题目的条件 求解一个类似的题目：分析和记忆题目尽量抽象，便于建立知识本质联系，便于知识的迁移 列出和问题相关的知识 考察反面，考察所有其它的情况 将问题泛化：有些问题泛化后更简单 意识孵化发：将问题放进潜意识 烫手山芋法：给别人做吧 知识是思维的桎梏：知识提供了解决问题无与伦比的捷径，获取知识优势的同时防止被知识束缚是一门艺术。抽象是掌握这门技术的钥匙。 知识是解题的罗塞塔石碑：如果解题的关键不能从已有的知识中推导出来。 看的见的思考：这是一个很好的习惯，将思考过程写下来，时不时回头看。 练习：将本来需要用脑子解决的问题，变成下意识的行为。减轻意识的负担。 soft knowledge：知识已经在脑袋中了，需要产生联系。 hard knowledge：知识不在脑袋里。 3-2 锤子和钉子手里拿着锤子，看什么都像钉子。第一次见，是芒格说的。这句话告诉我们要客观地对待工具。 手里拿着钉子，看什么都像锤子。。这句话是作者反复强调的一个观点：如果专注于想要解决的问题，那么所有看到的东西，都会呈现出你没有看到过的一面。 ### 3-3 鱼是最后一个看到水的：框架 人是有很强的适应性，喜欢在既有的框架下解决问题。 语言之争的原因之一是人容易在自己熟悉的语言框架下思考，并产生严重的偏见。一个程序员越是熟悉一个语言，就越是容易被这个语言所累。避免被一个语言束缚的方法就是学其它的语言。 C++ 在所有语言里面有特殊性 学习 C++ 的第一原则：关注基本的概念和技术，而非特定的语言特性。学习编程重点在学习基本的概念和素养，一旦掌握了基本概念，细节会自然到位。 使用 C++ 的第一原则：将你的设计理念直接映射为 C++ 中的类或模板。脱离语言思考，使用语言实现。 3-4 只其所以然欧几里得式总结，确实适合总结知识，但是真的失去了太多重要的思维细节。除了知道别人的思维细节很重要，整理自己的思维细节也很重要。 很多高效的方法是从错误低效的方法中得到的。 3-5 康托尔、哥德尔、图灵——永恒的金色对角线看不懂，晕了：希尔伯特希望将带有直观意义解释的数学系统变成毫无意义的符号表达。哥德尔的不完备定理，击碎了这一企图。哥德尔不完备定理证明了，数学永远有需要我们以人的头脑从系统之外用我们独特的直觉去发现的东西。 所以最后我的结论：计算机是数学家一次失败思考的产物。所以，总有它解决不了的问题，需要人的直觉到系统之外找。 3-6 快排为什么那么快 平衡型策略是糟糕情况下表现最好的，比如二分法，12 个小球称 3 次。 3-7 平凡而又神奇的贝叶斯方法 概率论不过是将常识用数学公式表达了出来。——拉普拉斯 历史贝叶斯方法被证明是非常具有一般性且强大的推理框架，很牛的方法。自然界是无穷且不确定的，人的观察是片面的，只能看到表面的结果。这个时候我们需要提供一个猜测，需要做两件事： 后验概率：算出各种不同猜想的可能性大小。 模型比较：算出最靠谱的猜想是什么。 自然语言的二义性：The girl saw the boy with a telescope. 这个平凡的贝叶斯公式： p(B|A) = \\frac{P(AB)}{P(A)}小孩子也可以求解贝叶斯问题：我们对形式化的贝叶斯问题不擅长，但是对以频率形式呈现出的等价问题却很擅长。人不是很擅长抽象思考，我怀疑别人遇到难题都是形象思考，再抽象归纳。思考多了，抽象能力也就上来了。 拼写纠正用户打错字的时候，我们猜测的哪个比较准呢？ 设我们猜测的的单词为事件 $h$，用户实际输入为事件 $D$，那么有： P(h|D) = \\frac{P(hD)}{P(D)}再次利用一下贝叶斯公式： P(h|D) = \\frac{P(hD)}{P(D)}=\\frac{P(h)\\times P(D|h)}{P(D)}而 $P(D)$ 是常量。一般会根据错误单词做一个 bottom-up 的关联提取，提选出有可能是对的后选单词，所以 P(h|D)\\propto P(h)\\times P(D|h)以上公式的说明，一个猜测的好坏是，猜测本身可能性的大小（先验）和这个猜测生成我们观测到的数据的可能性的大小（似然）的乘积。具体一下就是，用户输入 the 的可能性，取决于 the 本身在词汇表中出现的可能性，乘以想打出 the 却打出 thew 的可能性。 模型比较与奥卡姆剃刀 奥卡姆剃刀：如果两个理论具有相似的解释力度，优先选取解释力度更高的。","link":"/2021/03/24/%E9%9D%92%E9%9D%92%E8%8A%B3%E8%8D%89/%E3%80%8A%E6%9A%97%E6%97%B6%E9%97%B4%E3%80%8B/"},{"title":"matlab生成W-M分形形面","text":"一个二维的分形表面... 1 二维平面的 W-M 公式z(x)=G^{D-1}\\sum_{n=n1}^{\\infty}\\frac{cos(2 \\pi \\gamma^n x)}{\\gamma ^{(2-D)n}}$\\gamma=1.5$；$n$ 为自然序列，通常取 $n=1,2,3…100$。 matlab 中实现，取 $G=1$，$D$ 为 $1$ 和 $1.5$: 1234567891011clearclcG=1;n= 0:1:100;x = 1:1:1000;d = [1 1.5]f = @(x,n,d)1.5.^((d-2).*n).*cos(x.*1.5.^n.*2.*pi).*G.^(d-1)g = @(x,d)arrayfun(@(x)trapz(n,f(x,n,d)),x)plot(x,g(x,d(1)))figureplot(x,g(x,d(2)))","link":"/2021/03/18/%E5%8F%AF%E7%88%B1%E6%8C%96%E6%8E%98%E6%9C%BA/matlab%E7%94%9F%E6%88%90W-M%E5%88%86%E5%BD%A2%E5%BD%A2%E9%9D%A2/"},{"title":"对偶坐标系","text":"为了写出与坐标无关的公式，引入 “坐标系” 的 “对偶坐标系”。然后用 “度量张量” ，完成两个坐标系之间坐标的变换，常量的计算以及基矢量的变换。指标表示与指标运算特别重要。 1 概念 牢记这里的名称，既可以区分不同坐标系，又方便后面的运算： 协变坐标系 协变坐标 逆变基矢量 $O-x_1x_2x_3$ $x_1,x_2,x_3$ $\\pmb{x}^1,\\pmb{x}^2,\\pmb{x}^3$ 逆变坐标系 逆变坐标 协变基矢量 $O-x^1x^2x^3$ $x^1,x^2,x^3$ $\\pmb{x}_1,\\pmb{x}_2,\\pmb{x}_3$ 协变：一个变量扩大 $n$ 倍，另一个量跟着扩大 $n$ 倍。 逆变：一个变量扩大 $n$ 倍，另一个量跟着扩大 $\\frac{1}{n}$ 倍。 协变坐标会被写成一行，逆变坐标写成一列。 局部坐标系：基矢量的大小和方向将随着坐标点的不同而变化，是空间点的函数。例如曲线坐标系。 整体坐标系坐标系：基矢量的大小和方向不会随着坐标点的不同而变化，是常矢量。例如直角坐标系和仿射坐标系。 标架：空间一固定点 $O$ 与三个有序基矢量的构型全体。 2 直角坐标系及其对偶坐标系 直角坐标系 $O-x_1x_2x_3$，对应基矢量 $\\pmb{a}^i$。直角坐标系的对偶坐标系 $O-x^1x^2x^3$，对应基矢量 $\\pmb{a}_i$。 基矢量之间的关系： $\\pmb{a}^i$，$\\pmb{a}_i$ 都是单位正交基矢量。 直角坐标系与其对偶坐标系一模一样：$\\pmb{a}^1=\\pmb{a}_1$，$\\pmb{a}^2=\\pmb{a}_2$，$\\pmb{a}^3=\\pmb{a}_3$。 基矢量的点积运算可以简化为单位矩阵： \\pmb{a}_i\\cdot \\pmb{a}^j=\\delta^j_i=\\left[ \\begin{matrix} \\delta^1_1 & \\delta^1_2 & \\delta^1_3\\\\ \\delta^2_1 & \\delta^2_2 & \\delta^2_3\\\\ \\delta^3_1 & \\delta^3_2 & \\delta^3_3\\\\ \\end{matrix} \\right]=\\left[ \\begin{matrix} 1 & 0 & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1 \\end{matrix} \\right]采用对偶坐标系，是希望在仿射坐标系和曲线坐标系中，建立以上和直角坐标系中同样运算规则。比如说，希望在任何坐标系中 $W=\\pmb{F}\\cdot \\pmb{s}$ 都能求出功，功本来就和坐标系的选择无关。 3 仿射坐标系及其对偶坐标系 仿射坐标系 $O-x_1x_2x_3$，对应基矢量 $\\pmb{g}^i$。仿射坐标系的对偶坐标系 $O-x^1x^2x^3$，对应基矢量 $\\pmb{g}_i$。 在摄影和景物透视中经常遇到仿射坐标系。仿射坐标系的基矢量既不是单位矢量，也不正交。我们将方宽条件引入其对偶坐标系。 3-1 求出对偶坐标系 我们希望基矢量有以下关系： $$\\pmb{g}_i\\cdot \\pmb{g}^j=\\delta^j_i=\\left[ \\begin{matrix} 1 & 0 & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1 \\end{matrix} \\right]\\tag{3-1}$$ 在仿射坐标系中，有: $$\\pmb{g}_1\\cdot(\\pmb{g}_2\\times \\pmb{g}_3)=V\\tag{3-2}$$ 根据式 $(3-1)$ 和 $(3-2)$，可以求出： $$\\pmb{g}^1=\\frac{1}{V}(\\pmb{g}_2\\times \\pmb{g}_3)\\tag{3-3-1}$$ 同理： $$\\pmb{g}^2=\\frac{1}{V}(\\pmb{g}_1\\times \\pmb{g}_3)\\tag{3-3-2}$$ $$\\pmb{g}^3=\\frac{1}{V}(\\pmb{g}_2\\times \\pmb{g}_1)\\tag{3-3-3}$$ 3-2 两个坐标系的关系 基矢量分解 基矢量的分解，建立两个坐标之间的变换。 $1$ 个逆变基矢量可以沿着协变基矢量分解成 $3$ 个分量，$3$ 个逆变基矢量可以沿着协变基矢量分解成 $9$ 个分量。协变基矢量同理。用矩阵表示为： \\left[ \\begin{matrix} \\pmb{g}_1 \\\\ \\pmb{g}_2 \\\\\\pmb{g}_3 \\end{matrix} \\right]= \\left[ \\begin{matrix} g_{11} & g_{12} & g_{13}\\\\ g_{21} & g_{22} & g_{23}\\\\ g_{31} & g_{32} & g_{33} \\end{matrix} \\right] \\left[ \\begin{matrix} \\pmb{g}^1\\\\ \\pmb{g}^2\\\\ \\pmb{g}^3 \\end{matrix} \\right]\\tag{3-4}g_{ij}=\\left[ \\begin{matrix} g_{11} & g_{12} & g_{13}\\\\ g_{21} & g_{22} & g_{23}\\\\ g_{31} & g_{32} & g_{33} \\end{matrix} \\right]\\tag{3-5}$g_{ij}$ 称为度量张量，可以将指标降低，即将逆变基矢量变成协变基矢量。 同理，有 $g^{ij}$ 实现指标升高： \\left[ \\begin{matrix} \\pmb{g}^1\\\\ \\pmb{g}^2\\\\ \\pmb{g}^3 \\end{matrix} \\right]= \\left[ \\begin{matrix} g^{11} & g^{12} & g^{13}\\\\ g^{21} & g^{22} & g^{23}\\\\ g^{31} & g^{32} & g^{33} \\end{matrix} \\right]\\left[ \\begin{matrix} \\pmb{g}_1 \\\\ \\pmb{g}_2 \\\\\\pmb{g}_3 \\end{matrix} \\right] \\tag{3-6}坐标变换 度量张量可以实现基变换，也可以实现坐标变换。根据式 $(3-5)$，在逆变坐标系 $O-x^1x^2x^3$ 下的一个矢量 $\\pmb{v}$ 可以表示为： \\left[ \\begin{matrix} v^1 & v^2 & v^3 \\end{matrix} \\right]\\left[ \\begin{matrix} \\pmb{g}_1 \\\\ \\pmb{g}_2 \\\\\\pmb{g}_3 \\end{matrix} \\right]= \\left[ \\begin{matrix} v^1 & v^2 & v^3 \\end{matrix} \\right] \\left[ \\begin{matrix} g_{11} & g_{12} & g_{13}\\\\ g_{21} & g_{22} & g_{23}\\\\ g_{31} & g_{32} & g_{33} \\end{matrix} \\right] \\left[ \\begin{matrix} \\pmb{g}^1\\\\ \\pmb{g}^2\\\\ \\pmb{g}^3 \\end{matrix} \\right]\\tag{3-7}有坐标变换公式： \\left[ \\begin{matrix} v_1 & v_2 & v_3 \\end{matrix} \\right]= \\left[ \\begin{matrix} v^1 & v^2 & v^3 \\end{matrix} \\right] \\left[ \\begin{matrix} g_{11} & g_{12} & g_{13}\\\\ g_{21} & g_{22} & g_{23}\\\\ g_{31} & g_{32} & g_{33} \\end{matrix} \\right] \\tag{3-8}度量张量 以物理公式 $W=\\pmb{F}\\cdot \\pmb{s}$ 为例，看度量张量的好处。 如果将 $F$ 和 $s$ 都用逆变坐标表示，那么： W=\\pmb{F}\\cdot \\pmb{s}=f^is^j\\pmb{g}_i\\cdot \\pmb{g}_j\\tag{3-9}在仿射坐标系中，$\\pmb{g}_i\\cdot \\pmb{g}_j=1$ 不一定成立，但是我们希望物理定律，可以用一个不管在哪个坐标系中都一样的公式表示。 可以将两个向量一个用协变坐标表示，一个用逆变坐标表示。 W=\\pmb{F}\\cdot \\pmb{s}=f^is^j\\pmb{g}_i\\cdot \\pmb{g}_j=f^is^jg_{ij}\\pmb{g}^j\\cdot \\pmb{g}_j\\tag{3-10}我不会指标运算，这边根本不会用指标表示。是吧，会用指标运算很重要。","link":"/2021/03/17/%E6%95%B0%E5%AD%A6/%E5%AF%B9%E5%81%B6%E5%9D%90%E6%A0%87%E7%B3%BB/"},{"title":"ICARUS美化日志","text":"这么说不太好，但是 hexo 的坑真的多，好处就是不要钱吧... 1 首页三栏，文章两栏2021/3/16 参考别人的这个，没有成功，就用直觉，按别人的思路，随机改。最后 themes/icarus/layout/widget/layout.jsx被改成了这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const { Component } = require('inferno');const classname = require('hexo-component-inferno/lib/util/classname');const Head = require('./common/head');const Navbar = require('./common/navbar');const Widgets = require('./common/widgets');const Footer = require('./common/footer');const Scripts = require('./common/scripts');const Search = require('./common/search');module.exports = class extends Component { render() { const { site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets); if(page.path==='index.html'){ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-${columnCount}-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } else{ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-${columnCount}-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; } }}; 2 数学公式的渲染2021/3/16 参考这边 修改完之后，公式是没有关系了，但是标题渲染不出来了，先自己用 html 写吧。 1&lt;h1 id=&quot;1 概念&quot;&gt;&lt;a href=&quot;1 概念&quot; class=&quot;headerlink&quot; title=&quot;1 概念&quot;&gt;&lt;/a&gt;1 概念&lt;/h1&gt;","link":"/2021/03/16/%E5%8F%AF%E7%88%B1%E6%8C%96%E6%8E%98%E6%9C%BA/HEXO%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}],"tags":[{"name":"ICARUS","slug":"ICARUS","link":"/tags/ICARUS/"},{"name":"爱读书","slug":"爱读书","link":"/tags/%E7%88%B1%E8%AF%BB%E4%B9%A6/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"palabos","slug":"palabos","link":"/tags/palabos/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"tecplot","slug":"tecplot","link":"/tags/tecplot/"},{"name":"白噪音","slug":"白噪音","link":"/tags/%E7%99%BD%E5%99%AA%E9%9F%B3/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Matplotlib","slug":"Matplotlib","link":"/tags/Matplotlib/"},{"name":"数值计算","slug":"数值计算","link":"/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"无人机","slug":"无人机","link":"/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"},{"name":"语言","slug":"语言","link":"/tags/%E8%AF%AD%E8%A8%80/"}],"categories":[{"name":"可爱挖掘机","slug":"可爱挖掘机","link":"/categories/%E5%8F%AF%E7%88%B1%E6%8C%96%E6%8E%98%E6%9C%BA/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"白噪音","slug":"白噪音","link":"/categories/%E7%99%BD%E5%99%AA%E9%9F%B3/"},{"name":"青青芳草","slug":"青青芳草","link":"/categories/%E9%9D%92%E9%9D%92%E8%8A%B3%E8%8D%89/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"palabos","slug":"技术/palabos","link":"/categories/%E6%8A%80%E6%9C%AF/palabos/"},{"name":"计算机技术","slug":"技术/计算机技术","link":"/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"},{"name":"杂七杂八的软件","slug":"技术/杂七杂八的软件","link":"/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E8%BD%AF%E4%BB%B6/"}]}